Введение
Живая блокировка (Live Lock) — это одна из классических проблем многопоточного программирования. В отличие от Deadlock, где все потоки зависают и ничего не делают, в случае Live Lock потоки продолжают работать, но не могут продвинуться к выполнению своей задачи из-за постоянной реакции на действия друг друга.

Эта проблема особенно актуальна при разработке систем с высокой степенью параллелизма, таких как серверы, распределённые системы, обработчики событий и конкурентные алгоритмы [1].

В данной работе будет рассмотрена проблема Live Lock , её причины, пример реализации на языке Go , а также методы предотвращения. Также будут предложены две дополнительные задачи, связанные с этой темой.

1. Что такое Live Lock
Live Lock — это состояние системы, при котором два или более процессов активно реагируют на действия друг друга, освобождая ресурсы и повторяя попытку захвата, вместо того чтобы использовать их. Таким образом, прогресс не достигается, несмотря на активность всех участников.

Такое поведение часто возникает, когда процессы используют неблокирующиеся операции , такие как TryLock, и реагируют на конфликты , уступая друг другу без ожидания [2].

Пример из жизни:

Два человека пытаются пройти через узкий проход одновременно. Каждый уступает другому, и в результате никто не может пройти первым. 

2. Как возникает Live Lock
Live Lock обычно возникает в следующих случаях:

При использовании неблокирующихся примитивов синхронизации , например, TryLock
Когда несколько горутин активно уступают ресурс друг другу , вместо ожидания
В системах, где используется повторная попытка после отказа , без случайного элемента или таймаута
Код, в котором может произойти Live Lock:
package main

import (
    "fmt"
    "sync"
    "time"
)
type Chopstick struct {
    mutex sync.Mutex
}
func (c *Chopstick) PickUp(wg *sync.WaitGroup) {
    defer wg.Done()
    for {
        if c.mutex.TryLock() {
            fmt.Println("Chopstick picked up")
            time.Sleep(500 * time.Millisecond)
            c.mutex.Unlock()
            break
        } else {
            fmt.Println("Chopstick busy, retrying...")
            time.Sleep(100 * time.Millisecond)
        }
    }
}
func main() {
    var wg sync.WaitGroup
    cs := &Chopstick{}
    wg.Add(2)
    go cs.PickUp(&wg)
    go cs.PickUp(&wg)
    wg.Wait()
}

Этот код демонстрирует ситуацию, где две горутины постоянно конкурируют за один ресурс , вызывая Live Lock.
3. Разница между Deadlock, Starvation и Live Lock
ТИП ПРОБЛЕМЫ
ОПИСАНИЕ
РЕАКЦИЯ ПОТОКОВ
Deadlock
Все потоки заблокированы и ждут друг друга
Никто не работает
Starvation
Один или несколько потоков никогда не получают ресурс
Остальные работают, один голодает
Live Lock
Потоки работают, но не продвигаются
Активное "уступание".
4. Где встречается Live Lock
Примеры:
Сетевые протоколы : Ethernet, Wi-Fi, Bluetooth — устройства могут "переговариваться", откладывая передачу данных [3]
Распределённые системы : нода пытается выполнить задачу, но постоянно перепланируется из-за изменений состояния других нод
Базы данных : транзакции, которые откатываются из-за конкуренции и повторяются снова
Графические движки : объекты постоянно перемещаются, чтобы не пересекаться
Этот код демонстрирует ситуацию, где две горутины постоянно конкурируют за один ресурс , вызывая Live Lock.
